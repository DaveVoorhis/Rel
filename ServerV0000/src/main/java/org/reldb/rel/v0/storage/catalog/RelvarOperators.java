package org.reldb.rel.v0.storage.catalog;

import org.reldb.rel.exceptions.ExceptionSemantic;
import org.reldb.rel.v0.generator.Generator;
import org.reldb.rel.v0.generator.OperatorSignature;
import org.reldb.rel.v0.storage.*;
import org.reldb.rel.v0.storage.relvars.RelvarRealMetadata;
import org.reldb.rel.v0.values.*;

public class RelvarOperators extends RelvarSystem {
	
	public RelvarOperators(String name, RelDatabase database, RelvarRealMetadata metadata) {
		super(name, database, metadata);
	}
	
	private ValueTuple getTupleFor(Generator generator, String signature, String returnsType, String definition, String language, String generatedByType, String owner) {
		Value[] rawTuple = new Value[] {
			ValueCharacter.select(generator, signature),
			ValueCharacter.select(generator, returnsType),
			ValueCharacter.select(generator, definition),
			ValueCharacter.select(generator, language),
			ValueCharacter.select(generator, generatedByType),
			ValueCharacter.select(generator, owner),
			ValueInteger.select(generator, getDatabase().getUniqueID())
		};
		return new ValueTuple(generator, rawTuple);
	}
	
	private ValueTuple getTupleFor(Generator generator, String name, ValueRelationLiteral implementation) {
		Value[] rawTuple = new Value[] {
			ValueCharacter.select(generator, name),
			implementation							// implementations - attribute 2
		};
		return new ValueTuple(generator, rawTuple);
	}
	
	protected ValueTuple getKeyTuple(Generator generator, String name) {
		return getTupleFor(generator, name, null);
	}
	
	public void insertInternal(Generator generator, String name, String returnsType, String signature, String definition, String language, String generatedByType, String owner) {
		ValueTuple operatorTuple = getTupleForKey(generator, name);
		if (operatorTuple == null) {
			ValueRelationLiteral newImplementation = new ValueRelationLiteral(generator);
			newImplementation.insert(getTupleFor(generator, signature, returnsType, definition, language, generatedByType, owner));
			insertInternal(generator, getTupleFor(generator, name, newImplementation));
		} else {
			ValueRelationLiteral existingImplementations = (ValueRelationLiteral)operatorTuple.getValues()[1];
			TupleIterator implementationIterator = existingImplementations.iterator();
			try {
				while (implementationIterator.hasNext()) {
					ValueTuple implementationTuple = implementationIterator.next();
					String existingImplementationSignature = ((ValueCharacter)implementationTuple.getValues()[0]).stringValue();
					if (existingImplementationSignature.equalsIgnoreCase(signature))
						throw new ExceptionSemantic("RS0199: OPERATOR " + signature + " already exists.");
				}
			} finally {
				implementationIterator.close();
			}
			existingImplementations.insert(getTupleFor(generator, signature, returnsType, definition, language, generatedByType, owner));
			deleteInternal(generator, name);
			insertInternal(generator, getTupleFor(generator, name, existingImplementations));
		}
	}

	public void deleteInternal(Generator generator, OperatorSignature signature) {
		String name = signature.getName();
		ValueTuple operatorTuple = getTupleForKey(generator, name);
		if (operatorTuple == null) {
			throw new ExceptionSemantic("RS0200: OPERATOR " + signature + " could not be found.");
		} else {
			ValueRelationLiteral existingImplementations = (ValueRelationLiteral)operatorTuple.getValues()[1];
			TupleIterator implementationIterator = existingImplementations.iterator();
			try {
				while (implementationIterator.hasNext()) {
					ValueTuple implementationTuple = implementationIterator.next();
					String existingImplementationSignature = ((ValueCharacter)implementationTuple.getValues()[0]).stringValue();
					if (existingImplementationSignature.equalsIgnoreCase(signature.toRelLookupString())) {
						existingImplementations.remove(implementationTuple);
						deleteInternal(generator, name);
						if (existingImplementations.getCardinality() > 0)
							insertInternal(generator, getTupleFor(generator, name, existingImplementations));
						return;
					}
				}
			} finally {
				implementationIterator.close();
			}
			throw new ExceptionSemantic("RS0201: OPERATOR " + signature + " could not be found.");
		}
	}
	
	/** Get the name of the type that generated this operator.  Empty if not generated by a type, null if operator not found. */
	public String getOperatorGenerationTypeName(Generator generator, OperatorSignature signature) {
		ValueTuple operatorTuple = getTupleForKey(generator, signature.getName());
		if (operatorTuple == null)
			return null;
		ValueRelationLiteral existingImplementations = (ValueRelationLiteral)operatorTuple.getValues()[1];
		TupleIterator implementationIterator = existingImplementations.iterator();
		try {
			while (implementationIterator.hasNext()) {
				ValueTuple implementationTuple = implementationIterator.next();
				String existingImplementationSignature = ((ValueCharacter)implementationTuple.getValues()[0]).stringValue();
				if (existingImplementationSignature.equalsIgnoreCase(signature.toRelLookupString()))
					return ((ValueCharacter)implementationTuple.getValues()[4]).stringValue();
			}
		} finally {
			implementationIterator.close();
		}
		return null;
	}
	
	/** Return true if operator exists. */
	public boolean isOperatorExists(Generator generator, OperatorSignature signature) {
		ValueTuple operatorTuple = getTupleForKey(generator, signature.getName());
		if (operatorTuple == null)
			return false;
		ValueRelationLiteral existingImplementations = (ValueRelationLiteral)operatorTuple.getValues()[1];
		TupleIterator implementationIterator = existingImplementations.iterator();
		try {
			while (implementationIterator.hasNext()) {
				ValueTuple implementationTuple = implementationIterator.next();
				String existingImplementationSignature = ((ValueCharacter)implementationTuple.getValues()[0]).stringValue();
				if (existingImplementationSignature.equalsIgnoreCase(signature.toRelLookupString()))
					return true;
			}
		} finally {
			implementationIterator.close();
		}
		return false;	
	}
	
}
